## Redis的5种数据类型？：**字符串、哈希、列表、集合、有序集合**；

## **Redis基本数据类型与常用指令**

> 关键词：`String`、`Hash`、`List`、`Set`、`Zset`

- **String：**redis 的String可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。
- **List**链表（Redis用双端链表实现List）：List结构可以实现最新消息排队功能（比如[新浪](https://www.nowcoder.com/jump/super-jump/word?word=新浪)[微博](https://www.nowcoder.com/jump/super-jump/word?word=微博)的TimeLine）。List的另一个应用就是消息队列，可以利用List的 PUSH 操作，将任务存放在List中，然后工作线程再用 POP 操作将任务取出进行执行。
- **hash** 是键值对的映射表，hash适合用于存储对象。
- **Set** 集合。集合中不能出现重复的数据。Redis 中集合是通过[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表)实现的，所以添加，删除，查找的复杂度都是 O(1)。
- **Zset：**Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。[redis](https://www.nowcoder.com/jump/super-jump/word?word=redis) 正是通过分数来为集合中的成员进行从小到大的[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)。

## 过期键的删除策略、淘汰策略

1. ### Redis过期键的删除策略

Redis的过期删除策略就是：**惰性删除**和**定期删除**两种策略配合使用。

1. **惰性删除**：客户端访问一个key的时候，Redis会先检查它的过期时间，发现过期就删除这个key。
2. **定期删除**：每隔一段时间，对一些key进行检查，删除里面过期的key。
3. **定时删除**：通过定时器对key的过期时间来临时，立即执行对键的删除操作。 

1. ### 如何设计Redis的过期时间？

通过`expire key seconds` 命令来设置数据的过期时间。返回1表明设置成功，返回0表明key不存在或者不能成功设置过期时间

```Shell
expire (key seconds)        // 为给定 key 设置过期时间，以秒计。
pexpire (key milliseconds)  // 设置 key 的过期时间以毫秒计。
```

Redis key 的过期时间和永久有效分别怎么设置：`expire` 和 `persist`命令。

1. ### 说一说Redis的缓存淘汰策略

   1. `volatile-lru`：**最近最少使用**的数据淘汰 
   2. `volatile-ttl`：**将要过期**的数据淘汰 
   3. `volatile-random`：**任意选择数据**淘汰 
   4. `allkeys-lru`：**最近最少使用**的数据淘汰 
   5. `allkeys-random`：**任意选择数据**淘汰 
   6. `no-enviction`（驱逐）：**禁止驱逐数据**

这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是 三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。

**使用策略规则**： 

- 数据呈现**幂律分布**，一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lr 
- 数据呈现**平等分布**，也就是所有的数据访问频率都相同，则使用 allkeys-random

## **缓存击穿、缓存穿透、缓存雪崩**

### **缓存击穿**

- 缓存中的**热点****`key`****在某个时间点失效**，导致过期后的请求没有命中缓存而直接打到了数据库中。

**解决方案:**

1. **热点数据设置永不过期**。
2. **定时刷新**。在后台启动一个轮训器，在每个 key快到过期时间时进行更新。
3. 增加互斥锁更新。在一个请求进来后如果检测到key失效后，上锁进行重新捞库更新，其他请求先阻塞等待,完成后释放锁，之后的请求都能请求到缓存。这会令那一刻部分线程请求较为耗时,但以一刻的性能抖动的代价解决.
4. 业务逻辑兜底。在缓存 key 中附带过期时间，每次业务逻辑做完后检查是否过期并进行刷新

### **缓存穿透**

- 缓存和数据库中都没数据，导致请求打到数据库中。（非法请求0，-1等）

**解决方案:**

1. 布隆过滤器。
2. 业务上校验非法请求。一些不存在的 key，大多数是因为一些非法的请求，在业务上做一些业务校验避免这类非法的 key。
3. 缓存设置默认值。当缓存没有时，返回默认值，不打到数据库里面

### **缓冲雪崩**

- 缓存中的全部 key 在某一时间点统一失效，导致请求打到数据库中。

**解决方案**：

1. 将过期时间离散化。将缓存中的全部 key 的过期时间不设置成同一时间，使用一个随机值将缓存 key 的过期时间分散开来
2. 二级缓存。做服务本地做二级缓存，当 redis缓存过期后，返回服务本地的缓存内容
3. 定时刷新。同缓存击穿（2）
4. 增加互斥锁更新。同缓存击穿（1）

![img](https://bytedancecampus1.feishu.cn/space/api/box/stream/download/asynccode/?code=MWUyNmU1ZDg1MTY2N2U2ZGE3MjAxNjMwNDY2MmU1N2Jfc1l4YlpLNThJVU9lYlFCQXlsS0tuNlZ4NEk5ZDhWNW5fVG9rZW46Ym94Y25vRldnWURkdTNwYWxCY2l3aXdMUWdlXzE2ODgzNTg2MTQ6MTY4ODM2MjIxNF9WNA)

## 一个String类型的值能存储最大容量是多少？ 答：512M

## 说说缓存不一致?

由于缓存和数据库不属于同一个数据源，本质上非原子操作，所以是无法保证强一致性的，只能去实现最终一致性。

解决方案：

- **延时双删**：先删除redis中数据，修改数据库的数据，延迟2秒，再删除redis。这样保证数据在修改的时候去把redis 的数据删完，然后去查数据库
- 利用工具(canal)将数据库的`binlog`日志采集发送到MQ中，然后通过ACK机制确认处理删除缓存

```Java
public void write(String key,Object data) {
    Redis.delKey(key);
    db.updateData(data) ;
    Thread.sleep(1000) ;
    Redis.delkey(key);
}
```

1. 先删缓存
2. 再写数据库(这两步和原来一样)
3. 休眠1秒，再删缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结

束，写请求可以删除读请求造成的缓存脏数据。自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。

## 什么是缓存预热?

缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。

如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中，对数据库造成流量的压力。

缓存预热解决方案: .

- 数据量不大的时候，工程启动的时候进行加载缓存动作:
- 数据量大的时候，设置一个定时任务脚本，进行缓存的刷新;
- 数据量太大的时候，优先保证热点数据进行提前加载到缓存。

## **Redis为什么用跳表而不用平衡树**

- 易于实现，在后期维护和拓展也容易，其他的树形结构实现起来较为复杂，并且如果有 rebalance 操作的话，代码也会很复杂 
- 内存占用小，比起树形结构的存储内存，链式存储结构占用内存更小 
- 范围查找和其他树形结构时间复杂度差不多 

## Redis是单线程的，为什么这么快？

1. **单线程执行** 避免了线程切换和竞争所产生的消耗；
2. **基于内存存储**。数据存在内存中，没有磁盘IO上的开销。
3. **IO****多路复用机制**，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。

## **Redis到底是单线程还是多线程**

这里的单线程和多线程指的是工作线程。

1. redis 5.0 之前工作线程都是单线程，但在4.0 的时候，redis 已经有后台线程去处理一些不影响正常流程的工作，比如批量删除过期 key、清理脏数据、无用连接的释放、大 Key 的删除。
2. redis 5.0 之后的工作线程就是多线程，**因为** **redis** **的性能瓶颈在于网络****IO**，所以 redis 将对于网络 iO 的读写启了一些线程去进行，**核心的执行命令线程还是单线程**，另外因为是一个网络请求一个线程去读写，所以也没有竞态问题。

## **redis的geo是怎么实现的**

- 使用`geohash`保存地理位置的坐标。
- 使用有序集合（zset）保存地理位置的集合。

## Redis的持久化方式：RDB和AOF 

```
Redis`的持久化方式有两种：`RDB`和`AOF
```

- **RDB**：通过数据集快照记录redis中的所有数据，在某个时间段内，将数据写入一个临时文件中，持久化结束，用这个临时文件替换上次的持久化文件，达到数据恢复。
  - 好处：
    - 只有一个文件`dump.rdb`，方便持久化。
    - 容灾性好，一个文件可以保存到安全的磁盘。
    - 性能最大化。子进程来完成写操作，主进程继续处理命令。
  - 缺点：数据安全性低，RDB是隔一段时间进行一次备份，在此期间，如果发生了异常，导致数据丢失。
- **AOF**：通过记录redis的所有命令，执行一次就记录一次数据，保存在AOF文件中。
  - 优点：保证了数据的安全性和完整性，即便是中途宕机，也可以恢复过来。
  - 缺点：
    - AOF 文件比 RDB 文件大，且恢复速度慢。
    - 数据集大的时候，比 rdb 启动效率低。 **Redis默认是用RDB文件存储**。 

## **简述 Redis 的三种集群模式以及区别**

1. 主从模式，一主多从用于读写分离和数据备份，但是没有高可用的保证
2. 哨兵模式，主从模式的基础上引进了哨兵节点去监控主从集群，进行故障检测以及转移等高可用措施
3. 集群模式，多节点用于数据分片，也支持高可用

## 使用过 Redis 分布式锁么，它是什么回事 

先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。 

这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？

这时候你要给 予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓 自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小 子还不错。

## **什么是 raft ，解决了什么问题**

raft 是分布式一致性算法，用来解决分布式集群中多个服务节点的一致性问题

raft 把分布式一致性问题分成了三个问题，解决了这三个问题就能认为整个分布式集群是强一致（或者说是线性一致的）的

1. 分布式集群的 leader 选举
2. 主从日志复制
3. 集群容错的安全性问题