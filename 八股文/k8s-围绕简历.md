## **K8S架构**

#### **Kubernetes架构**

Kubernetes 搭建需要至少两个节点，一个Master节点负责管理，一个worker节点搭建在工作服务器上负责分配。

从图中可以看到各个组件的基本功能：

- API Server：
- controller-manager：作为K8s的核心组件，主要做资源调度，根据集群情况分配资源
- etcd：，存储集群的状态信息
- scheduler：负责调度每个工作节点
- cloud-controller-manager：负责调度其他云服务产品
- kubelet：管理Pods上面的容器。
- kube-proxy：负责处理其他work或客户端的请求。
- Pod：可以理解为就是运行的容器

### **1. master node(控制节点)**

1. API server：资源操作的唯一入口，作为K8s通讯的核心组件，K8s内部交互以及接收发送指令的组件。（相当于前端控制器）。接受用户输入的命令，提供认证，授权、API注册和发现等机制
2. scheduler：(调度器)负责集群资源的调度，按照预定的调度策略将pod调度到相应的node节点上
3. controller-manager：负责维护集群的状态，比程序部署安排，故障检测，自动扩展，滚动更新等
4. Etcd：一个key-value的数据库负责存储集群中各种资源对象的信息

### **2. worker node(工作节点)**

1. kubelet作用：管理本机的容器
2. kube-proxy作用：负责提供集群内部的服务发现和负载均衡
3. Pod：负责节点上容器的各种操作

## **软硬连接的区别**

对于管理大量linux服务器的思路和方案 ：SaltStack/ansible运维工具库

这一个shell脚本，把A目录下以.conf结尾的文件移动到B目录下，并更名为.html

# **pod健康检查之容器的存活探针、就绪探针**

## **存活探针（liveness probe）**

存活探针检查容器是否还在运行，可以为pod中每个容器单独定义存活指针，kubernetes将定期执行探针，如果探测失败，将杀死容器，并根据restartPolicy策略来决定是否重启容器。

## **3种类型的存活探针**

kubernetes提供了3种探测容器的存活探针，如下：

1. httpGet：根据容器的IP、端口、路径发送http请求，返回200-400范围内的状态码表示成功；
2. exec：在容器内执行shell命令，根据命令退出状态码是否为0判定成功失败；
3. TCPSocket：与容器的端口建立TCP Socket链接；

## **就绪探针（readiness probe）**

我们知道，当一个pod启动后，就会立即加入service的endpoint ip列表中，并开始接收到客户端的链接请求，假若此时pod中的容器的业务进程还没有初始化完毕，那么这些客户端链接请求就会失败，为了解决这个问题，kubernetes提供了就绪探针来解决这个问题的。

在pod中的容器定义一个就绪探针，就绪探针周期性检查容器，如果就绪探针检查失败了，说明该pod还未准备就绪，不能接受客户端链接，则该pod将从endpoint列表中移除，被剔除了service就不会把请求分发给该pod，然后就绪探针继续检查，如果随后容器就绪，则再重新把pod加回endpoint列表。

## **就绪探针的三大类型**

就绪探针也有三种类型HTTP GET，Exec和TCP Socket。

1. exec：执行容器中的命令并检查命令退出的状态码，如果状态码为0则说明容器已经准备就绪；
2. httpGet：向容器发送http get请求，通过响应的http状态码判断容器是否准备就绪；
3. tcpSocket：打开一个tcp连接到容器的指定端口，如果连接已建立，则认为容器已经准备就绪。

## **容器和pod关系**

1个pod可以包含1个或多个容器，可以理解为pod是容器的容器。我们可以通过kubectl descile pod < pod name> -n < namespace _name> 命令查看对应pod的容器信息，或者直接查看yaml源文件。

## **pod**

1. pod是k8s调度的最小单元。
2. 1个pod可以包含1个或多个容器，可以理解为pod是容器集合。
3. pod相当于逻辑主机，每个pod通过describe可以看到都有自己的ip地址。
4. pod内的容器可以共享相同的ip和端口空间。
5. 进入pod后，正常的Iinux命令可以使用，若pod内包含多个容器，进入到每个容器都相当于进入了一个逻辑主机。

## **容器**

1. docker包括三个概念: 镜像(image) ，容器(container) 、仓库(repository)
2. 容器就是镜像运行时的实体，镜像和容器的关系类比与Java面向对象程序设计中的类和实例是-样的概念。
3. 每个容器的文件系统与其他容器是隔离的。
4. 容器可以被创建、启动、停止、删除以及暂停等。
5. 容器的实质是进程，运行于属于自己独立的命名空间。
6. 容器内的存储层是跟随容器变化的，生命周期同容器保持一致。容器删除，则存储层信息丢失。所以存储东西最好使用存储卷(volume)、绑定宿主目录等方式。
7. 容器是应用程序层的一种抽象，将代码和依赖关系打包在- -起，可以多个容器同时运行在同- -台机器上，并与其他容器共享操作系统内核。

问我的问题有：

1. k8s的pod和docker容器有什么区别
2. 1个pod可以包含1个或多个容器，可以理解为pod是容器的容器。pod是k8s调度的最小单元。
3. flannel和calico的区别
4. flannel的功能比较简单，不具备复杂网络的配置能力，calico是比较出色的网络管理插件，单具备复杂网络配置能力的同时，往往意味着本身的配置比较复杂，所以相对而言，比较小而简单的集群使用flannel，考虑到日后扩容，未来网络可能需要加入更多设备，配置更多策略，则使用calico更好。
5. Calico是一个纯三层的网络插件，calico的bgp模式类似于flannel的host-gw。
6. Calico方便集成OpenStack这种 IaaS云架构，为openstack虚拟机、容器、裸机提供多主机间通信。
7. 
8. 如何部署k8s集群
9. 部署k8s的两种方式：
10. 目前生产部署Kubernetes集群主要有两种方式：
    1. kuboard
    2. kuboard是一个K8s部署工具，用于快速部署Kubernetes集群。
    3. 二进制包
    4. 从github下载发行版的二进制包， 手动部署每个组件，组成Kubernetes集群。
11. 你在做实验的时候遇到过什么问题？怎么解决的
12. deployment statemonset daemonset job/cronjob的区别
13. 什么是Pod控制器？
14. Pod控制器是管理Pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod
15. 在Kubernetes中，有很多类型的Pod控制器，每种都有自己的适合的场景，常见的有下面这些：
    1. ReplicationController：比较原始的Pod控制器，已经被废弃，由ReplicaSet替代
    2. ReplicaSet：保证副本数量一直维持在期望值，并支持Pod数量扩缩容，镜像版本升级
    3. Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本
    4. DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务
    5. Job：它创建出来的Pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务
    6. CronJob：它创建的Pod负责周期性任务控制，不需要持续后台运行
    7. StatefulSet：管理有状态应用
16. 你的主机ping不通外网了，你应该怎么排查
    1. 检查物理链路是否有问题。
    2. 查看本机IP地址、路由、DNS的设置是否有问题。
    3. 测试网关或路由器的通畅情况。先测网关然后再测路由器,一级一级地测试。
    4. 测试ping公网ip的通畅情况(平时要记几个外部IP)。

我项目写的k8s和mysql，mysql提问是一个开放性问题，直接让我谈谈数据库，我就说了mysql主从复制原理，异步复制，同步，半同步复制原理，数据库优化方法（我是从四个方面说的，硬件，系统配置，数据结构，sql语句和索引），还有数据库的增删改查命令，mysql和redis的区别，redis哨兵的部署

### **安装 kubeadm、kubelet 和 kubectl**

kubeadm：用来初始化集群的指令。

kubelet：在集群中的每个节点上用来启动 Pod 和容器等。

kubectl：用来与集群通信的命令行工具。

## **Kubernetes通信问题**

1. 容器间通信：即同一个Pod内多个容器间通信，通常使用loopback来实现。
2. Pod间通信：K8s要求,Pod和Pod之间通信必须使用Pod-IP 直接访问另一个Pod-IP
3. Pod与Service通信：即PodIP去访问ClusterIP，当然，clusterIP实际上是IPVS或iptables规则的虚拟IP，是没有TCP/IP协议栈支持的。但不影响Pod访问它.
4. Service与集群外部Client的通信，即K8s中Pod提供的服务必须能被互联网上的用户所访问到。

## **数据库/表 如何设计**

不要说DBA帮你设计

1. 用powerdisigner去设计
2. 思想：我首先是根据需求文档去整理出有哪些功能模块。看看哪些功能模块之间有关联的。然后整理出初版的表，先把表确定下来，接着根据需求文档去分析有哪些字段，包括隐藏的业务字段。（外键等等）。我们数据库表设计的时候有一些规范，不管表里有哪些字段。主键，修改日期，创建日期必须有，遵循驼峰命名法。初版数据库设计填写完之后我们会开一个例会，对表的科学性可执行性进行讨论，然后大家意见统一一下，把不足之处再进行二次修改。所有人觉得没问题完成表之后呢，再开一次会，然后交给DBA去

## **导入数据量大，导致Java内存溢出**

为了避免出现这个问题，我们采取了批量处理的方式