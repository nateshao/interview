## **http与https，http1.0，1.1，2.0，3.0**

**HTTP 1.0**

1. **无状态，无连接.**   服务器处理完成后立即断开`TCP`连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）
2. **短连接**：每次发送请求都要重新建立tcp请求，即三次握手，非常浪费性能
3. **无host头域**，也就是http请求头里的host，
4. **不允许断点续传**，而且不能只传输对象的一部分，要求传输整个对象

**HTTP 1.1**

1. 长连接，流水线，使用connection：keep-alive使用长连接
2. 请求管道化
3. 增加缓存处理(新的字段如cache-control)
4. 增加Host字段，支持断点传输等
5. 由于长连接会给服务器造成压力

**HTTP 2.0**

1. **二进制分帧**
2. **头部压缩**，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小
3. **IO****多路复用**(或连接共享)，使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求
   1. `HTTP/2`引入`二进制数据帧`和`流`的概念，其中帧对数据进行顺序标识。有了序列，服务器就可以并行的传输数据，这就是`流`所做的事情。
   2. `HTTP/2`对同一域名下所有请求都是基于`流`，**同个域名只需要占用一个 TCP 连接，使用一个连接并行发送多个请求和响应。**

**HTTP 3.0**

1. 基于google的QUIC协议，而quic协议是使用udp实现的
2. 减少了tcp三次握手时间，以及tls握手时间
3. 解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题
4. 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗
5. 连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接
6. 更合适的流量控制

**HTTP1.0**：

比如说**连接无法复用**的问题，每次请求都要进行三次握手，重新建立连接，效率太低。还有就是**阻塞**问题，http1.0是下一个请求的发送必须要等到上一个请求返回后才会进行，如果上一个请求没有返回，那么后面的请求就会全部阻塞。最后就是**安全**问题，http1.0所传输的内容都是明文的，无法保证数据的安全性。

**HTTP1.1**： `KeepAlived` 长连接避免了连接建立和释放的开销；通过`Content-Length`来判断当前请求数据是否已经全部接受（有状态）

**HTTP2.0**：引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。还引入多路复用，可以只通过一个 TCP 连接传输所有的请求数据。

还有就是采用了头部压缩技术，这也成功解决了http1.0的header 里携带的内容过大的问题，在一定程度上减轻了传输的成本。不过它也存在一定的问题，如果在传输的过程中存在丢包的情况的话，那么整个tcp就得重新传输，后面资源就会被阻塞。

HTTP3.0：它最大的不同是放弃了tcp协议而是改用了 QUIC协议，此协议基于传输层UDP协议。UDP协议无需三次握手四次挥手，所以传输速率更高。

1. **线头阻塞问题更加彻底**。它改善了多路复用产生的问题，如果出现丢包的情况，不需要整个重新发送，只需要重发丢掉的包就可以。
2. **网络切换时连接保持。**在当前移动端的应用环境，用户网络会经常切换（如4g切换WiFi），基于TCP的协议，由于切换网络之后，IP会改变，所以说之前建立的连接会断开。而基于UDP的Http3.0，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换后，恢复之前的服务器连接

## HTTP和 HTTPS的区别：

1. 有5方面：安全性-端口不同-响应速度-证书-加密
   1. 最重要的区别就是安全性，`HTTP`明文传输，不对数据进行加密安全性较差。`HTTPS`(HTTP + SSL / TLS)的数据传输过程是加密的，安全性较好。
   2. 端口不同：`HTTPS`和 `HTTP`使用的是完全不同的连接方式，用的端口也不一样，前者是 `443`，后者是 `80`。
   3. 响应速度：`HTTP`页面响应速度比 `HTTPS`快，这个很好理解，由于加了一层安全层，建立连接的过程更复杂，也要交换更多的数据，难免影响速度。
   4. 证书：使用 `HTTPS`协议需要申请 `CA`证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：`Symantec`、`Comodo`、`DigiCert`和 `GlobalSign`等。
   5. 加密：`HTTP`协议运行在`TCP`（三次握手）之上，所有传输的内容都是明文，`HTTPS`运行在`SSL/TLS`之上，`SSL/TLS`运行在`TCP`之上，所有传输的内容都经过加密的。

## TCP与UDP区别及场景

| 类型 | 特点                       | 性能                   | 应用过场景       | 首部字节 |
| ---- | -------------------------- | ---------------------- | ---------------- | -------- |
| TCP  | 面向连接、可靠、字节流     | 传输效率慢、所需资源多 | 文件、邮件传输   | 20-60    |
| UDP  | 无连接、不可靠、数据报文段 | 传输效率快、所需资源少 | 语音、视频、直播 | 8个字节  |

## **TCP协议如何保证可靠传输机制？**

TCP主要提供了**检验和、超时重传、滑动窗口、拥塞控制和流量控制、****序列号****/确认应答**等方法实现了可靠性传输**。**

- **检验和：**通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃`TCP`段，重新发送。
- **超时重传：**超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。
- **滑动窗口：**滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。
- **拥塞控制：**在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证`TCP`可靠性的同时，提高性能。
- **流量控制：**如果主机A一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与`TCP`协议报头中的窗口大小有关。
- **序列号****/确认应答：**序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。`TCP`传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送`ACK`报文，这个`ACK`报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

## **TCP粘包原因和解决方法**

**TCP粘包是什么**：发送方发送的多个数据包，到接收方后粘连在一起，导致数据包不能完整的体现发送的数据。

**TCP粘包原因分析**：导致TCP粘包的原因，可能是发送方的原因，也有可能是接受方的原因。

对于粘包和拆包问题，常见的解决方案**有四种**：

1. 包都固定长度，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；
2. 在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；
3. 将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；
4. 通过自定义协议进行粘包和拆包的处理。

## 浏览器输入URL过程：

1. `DNS`解析、`TCP`连接、发送`HTTP`请求、服务器处理请求并返回`HTTP`报文、浏览器渲染、结束。

## 三次握手过程：

1. 客户端——发送带有`SYN`标志的数据包——服务端 一次握手 客户端进入`syn_sent`状态
2. 服务端——发送带有`SYN/ACK`标志的数据包——客户端 二次握手 服务端进入`syn_rcvd`
3. 客户端——发送带有`ACK`标志的数据包——服务端 三次握手 连接就进入`Established`状态

## 四次挥手过程：

1. 客户端——发送带有`FIN`标志的数据包——服务端，关闭与服务端的连接 ，客户端进入`FIN-WAIT-1`状态
2. 服务端收到这个 `FIN`，它发回⼀ 个 `ACK`，确认序号为收到的序号加`1`，服务端就进入了`CLOSE-WAIT`状态
3. 服务端——发送⼀个`FIN`数据包——客户端，关闭与客户端的连接，客户端就进入`FIN-WAIT-2`状态
4. 客户端收到这个 `FIN`，发回 `ACK`报⽂确认，并将确认序号设置为收到序号加`1`，客户端进入`TIME-WAIT`状态

### **为什么 TCP 建立连接需要三次握手而不是，二次和四次**

因为 TCP 连接是**全双工**，客户端和服务端都需要具备收和发的功能，**三次的握手就能够让双方都知道对方是具备收和发的功能的**。

二次握手，会让客户端知道服务端都会收和发，但缺了一次握手会让服务端不知道客户端可以收。还有是二次握手有可能会建立多余的连接，因为发起第一次握手时，有可能因为网络原因没有到达服务端处，会重试在发送一次建立连接，而前面的那次因为网络延迟又到达了服务端处，最后的结果会导致建立了两个连接，造成资源的浪费

四次握手，前面提到的，三次握手让双方都知道对方可以收和发，多了一次没有实际任何的意义

### **tcp 四次挥手为什么要四次**

1. tcp 是**全双工**的连接，双方都需要告知对方关闭，告知时都需要经过一个来回
2. 第二次和第三次挥手时，服务端的 ack + fin 不能一起回复。因为第一次挥手时，客户端告知了服务端要关闭连接，但是服务端可能还有数据要发给客户端处理，所以先回复一个 ack 的应答，再服务端主动关闭连接发起 fin 之前，还有剩余的数据包需要发送过

##  **127.0.0.1、0.0.0.0、****localhost** **这三者有什么区别**

- **`localhost`** **是一个域名。**通常在每台机器的 `host` 文件都会配置指向 127.0.0.1。比如 mac 下可以用 `cat /etc/hosts` 查看
- **127.0.0.1 是本地回环地址。**任何发送给这个地址的数据，从 TCP/IP协议族去看的话，都会发送到 IP 层之后被本地捕获，不会从 IP 层发到下层链路层再到网络。外部也无法根据这个地址访问到。
- **0.0.0.0 指的是本机所有网卡的地址。**所以如果本机有两个网卡对应有两个对外的 IP 地址，那么监听 0.0.0.0 的时候会同时监听这两个 IP 地址。

1. 用过什么linux，docker命令？
   1. linux
      1. 查端口netstat -aux| grep 镜像名称
      2. 查进程 ps -aux | grep 进程号
      3. 查cpu top命令
      4. 查内存 free
   2. docker查看镜像，容器，安装mysql，nginx，redis镜像、部署、迁移备份，通过dockerfile部署Springboot SpringCloud项目
   3. 新建Dockerfile文件(Dockerfile和jar包要在同一个文件夹下哦)
      1. Dockerfile

```Dockerfile
 FROM java:8
 EXPOSE 8080
 
 VOLUME /tmp
 
 ENV TZ=Asia/Shanghai
 RUN ln -sf /usr/share/zoneinfo/{TZ} /etc/localtime && echo "{TZ}" > /etc/timezone
 
 ADD eblog-0.0.1-SNAPSHOT.jar  /app.jar
 RUN bash -c 'touch /app.jar'
 ENTRYPOINT ["java","-jar","/app.jar"]
```

- FROM java:8 表示基于jdk8环境
- EXPOSE 8080 表示对外暴露的端口是8080
- VOLUME /tmp 表示挂载到/tmp目录
- ADD eblog-0.0.1-SNAPSHOT.jar /app.jar 表示把jar包复制到镜像服务里面的根目录，并改名称app.jar
- RUN bash -c 'touch /app.jar' 表示执行创建app.jar
- ENTRYPOINT ["java","-jar","/app.jar"] 表示执行启动命令java -jar